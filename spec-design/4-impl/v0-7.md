# Fuel Project Implementation Guide

This document provides an exhaustive sequence of steps to build the Fuel project from scratch in `~/Desktop/fuel`. Following these steps will create a fully functional application with frontend, backend, and PostgreSQL database.

## Prerequisites
- Node.js 18+
- Docker and Docker Compose
- Git (existing fuel repo)

## Phase 1: Project Structure & Initialization

### Step 1.1: Navigate to Existing Git Repository
```bash
cd ~/Desktop/fuel
```

### Step 1.2: Create Directory Structure
```bash
mkdir -p database/migrations
mkdir -p backend/src/{config,models,services,middleware,routes,types,cli}
mkdir -p backend/tests/{integration,unit}
mkdir -p frontend/src/{components/{Header,Sidebar,MainView},hooks,services,stores,types,styles}
mkdir -p frontend/tests/{e2e,unit}
```

## Phase 2: Database Layer (V0.3)

### Step 2.1: Create Database Migrations
Create `database/migrations/001_initial_schema.sql`:
```sql
-- Connected Local Git Repositories
CREATE TABLE connected_local_git_repos (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    local_repo_path TEXT NOT NULL UNIQUE,
    remote_url TEXT,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Activity Logs (Central logging table)
CREATE TABLE activity_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    type VARCHAR(50) NOT NULL CHECK (type IN ('manual', 'git_commit', 'claude_code', 'git_checkout', 'git_hook_install')),
    reviewed BOOLEAN DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    reviewed_at TIMESTAMP WITH TIME ZONE
);

-- Manual Logs
CREATE TABLE manual_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    activity_id UUID NOT NULL UNIQUE REFERENCES activity_logs(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Git Commits
CREATE TABLE git_commits (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    activity_id UUID NOT NULL UNIQUE REFERENCES activity_logs(id) ON DELETE CASCADE,
    repo_id UUID NOT NULL REFERENCES connected_local_git_repos(id) ON DELETE CASCADE,
    commit_hash VARCHAR(40) NOT NULL,
    message TEXT NOT NULL,
    author_name VARCHAR(255),
    author_email VARCHAR(255),
    committed_at TIMESTAMP WITH TIME ZONE NOT NULL,
    files_changed TEXT[],
    metadata JSONB,
    UNIQUE(commit_hash, repo_id)
);

-- Claude Code Conversations
CREATE TABLE claude_code_conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    activity_id UUID NOT NULL UNIQUE REFERENCES activity_logs(id) ON DELETE CASCADE,
    project_directory_name VARCHAR(255),
    conversation_file_path TEXT NOT NULL,
    raw_jsonl TEXT,
    parsed_content JSONB,
    bullet_points TEXT[],
    num_exchanges INTEGER DEFAULT 0,
    num_tool_usages INTEGER DEFAULT 0,
    num_tokens INTEGER DEFAULT 0,
    started_at TIMESTAMP WITH TIME ZONE,
    ended_at TIMESTAMP WITH TIME ZONE,
    metadata JSONB
);

-- Git Checkouts
CREATE TABLE git_checkouts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    activity_id UUID NOT NULL UNIQUE REFERENCES activity_logs(id) ON DELETE CASCADE,
    repo_id UUID NOT NULL REFERENCES connected_local_git_repos(id) ON DELETE CASCADE,
    timestamp VARCHAR(255) NOT NULL,
    prev_head VARCHAR(40) NOT NULL,
    new_head VARCHAR(40) NOT NULL,
    prev_branch VARCHAR(255) NOT NULL,
    new_branch VARCHAR(255) NOT NULL,
    repo_path TEXT NOT NULL,
    repo_name VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Git Hooks Installed
CREATE TABLE git_hooks_installed (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    activity_id UUID NOT NULL UNIQUE REFERENCES activity_logs(id) ON DELETE CASCADE,
    repo_id UUID NOT NULL REFERENCES connected_local_git_repos(id) ON DELETE CASCADE,
    hook_type VARCHAR(50) NOT NULL,
    hook_script_path TEXT,
    installation_timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
    repo_path TEXT NOT NULL,
    repo_name VARCHAR(255) NOT NULL,
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```

Create `database/migrations/002_add_indexes.sql`:
```sql
-- Performance indexes for common query patterns
CREATE INDEX idx_activity_logs_created_at ON activity_logs(created_at);
CREATE INDEX idx_activity_logs_type ON activity_logs(type);
CREATE INDEX idx_activity_logs_reviewed ON activity_logs(reviewed);
CREATE INDEX idx_activity_logs_type_reviewed ON activity_logs(type, reviewed);

CREATE INDEX idx_manual_logs_activity_id ON manual_logs(activity_id);
CREATE INDEX idx_git_commits_activity_id ON git_commits(activity_id);
CREATE INDEX idx_git_commits_repo_id ON git_commits(repo_id);
CREATE INDEX idx_git_commits_hash ON git_commits(commit_hash);

CREATE INDEX idx_claude_conversations_activity_id ON claude_code_conversations(activity_id);
CREATE INDEX idx_git_checkouts_activity_id ON git_checkouts(activity_id);
CREATE INDEX idx_git_checkouts_repo_id ON git_checkouts(repo_id);

CREATE INDEX idx_git_hooks_activity_id ON git_hooks_installed(activity_id);
CREATE INDEX idx_git_hooks_repo_id ON git_hooks_installed(repo_id);

CREATE INDEX idx_connected_repos_active ON connected_local_git_repos(is_active);
CREATE INDEX idx_connected_repos_path ON connected_local_git_repos(local_repo_path);
```

## Phase 3: Backend Implementation (V0.5)

### Step 3.1: Initialize Backend Package
Create `backend/package.json`:
```json
{
  "name": "fuel-backend",
  "version": "1.0.0",
  "description": "Fuel activity logging backend",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "nodemon --exec ts-node src/index.ts",
    "test": "jest",
    "test:watch": "jest --watch"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "postgres": "^3.4.3",
    "uuid": "^9.0.1",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/cors": "^2.8.17",
    "@types/uuid": "^9.0.7",
    "@types/node": "^20.10.0",
    "typescript": "^5.3.0",
    "nodemon": "^3.0.2",
    "ts-node": "^10.9.1",
    "jest": "^29.7.0",
    "@types/jest": "^29.5.8"
  }
}
```

Create `backend/tsconfig.json`:
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}
```

Install backend dependencies:
```bash
cd backend
npm install
```

### Step 3.2: Database Configuration
Create `backend/src/config/database.ts`:
```typescript
import postgres from 'postgres'

export class DatabaseConfig {
    private sql: postgres.Sql<{}>

    constructor() {
        const connectionString = process.env.DATABASE_URL || 'postgresql://fuel_user:fuel_password@localhost:5432/fuel_db'
        this.sql = postgres(connectionString, {
            max: 10,
            idle_timeout: 20,
            connect_timeout: 10,
        })
    }

    public getConnection(): postgres.Sql<{}> {
        return this.sql
    }

    public async close(): Promise<void> {
        await this.sql.end()
    }
}

export const db = new DatabaseConfig().getConnection()
```

### Step 3.3: Database Models (with DELETE support)
Create `backend/src/models/ActivityLog.ts`:
```typescript
import { db } from '../config/database'

export interface ActivityLogRow {
    id: string
    type: 'manual' | 'git_commit' | 'claude_code' | 'git_checkout' | 'git_hook_install'
    reviewed: boolean
    created_at: Date
    reviewed_at: Date | null
}

export interface ActivityLogFilters {
    from_date?: string
    to_date?: string
    reviewed?: boolean
    type?: string
}

export interface CreateActivityLogData {
    type: ActivityLogRow['type']
    reviewed?: boolean
}

export interface UpdateActivityLogData {
    reviewed?: boolean
    reviewed_at?: Date
}

export class ActivityLog {
    static async findAll(filters?: ActivityLogFilters): Promise<ActivityLogRow[]> {
        let query = `SELECT * FROM activity_logs WHERE 1=1`
        const params: any[] = []
        let paramCount = 0

        if (filters?.from_date) {
            query += ` AND created_at >= $${++paramCount}`
            params.push(filters.from_date)
        }
        if (filters?.to_date) {
            query += ` AND created_at <= $${++paramCount}`
            params.push(filters.to_date)
        }
        if (filters?.reviewed !== undefined) {
            query += ` AND reviewed = $${++paramCount}`
            params.push(filters.reviewed)
        }
        if (filters?.type) {
            query += ` AND type = $${++paramCount}`
            params.push(filters.type)
        }

        query += ` ORDER BY created_at DESC`

        return await db.unsafe(query, params)
    }

    static async findById(id: string): Promise<ActivityLogRow | null> {
        const results = await db`SELECT * FROM activity_logs WHERE id = ${id}`
        return results[0] || null
    }

    static async create(data: CreateActivityLogData): Promise<ActivityLogRow> {
        const results = await db`
            INSERT INTO activity_logs (type, reviewed)
            VALUES (${data.type}, ${data.reviewed || false})
            RETURNING *
        `
        return results[0]
    }

    static async update(id: string, data: UpdateActivityLogData): Promise<ActivityLogRow | null> {
        const results = await db`
            UPDATE activity_logs
            SET reviewed = ${data.reviewed}, reviewed_at = ${data.reviewed_at || null}
            WHERE id = ${id}
            RETURNING *
        `
        return results[0] || null
    }

    static async delete(id: string): Promise<boolean> {
        const result = await db`DELETE FROM activity_logs WHERE id = ${id}`
        return result.count > 0
    }

    static async markAsReviewed(ids: string[]): Promise<ActivityLogRow[]> {
        if (ids.length === 0) return []

        const results = await db`
            UPDATE activity_logs
            SET reviewed = true, reviewed_at = CURRENT_TIMESTAMP
            WHERE id = ANY(${ids})
            RETURNING *
        `
        return results
    }
}
```

Create `backend/src/models/ManualLog.ts`:
```typescript
import { db } from '../config/database'

export interface ManualLogRow {
    id: string
    activity_id: string
    content: string
    created_at: Date
    updated_at: Date
}

export class ManualLog {
    static async findByActivityId(activityId: string): Promise<ManualLogRow | null> {
        const results = await db`SELECT * FROM manual_logs WHERE activity_id = ${activityId}`
        return results[0] || null
    }

    static async create(activityId: string, content: string): Promise<ManualLogRow> {
        const results = await db`
            INSERT INTO manual_logs (activity_id, content)
            VALUES (${activityId}, ${content})
            RETURNING *
        `
        return results[0]
    }

    static async update(activityId: string, content: string): Promise<ManualLogRow | null> {
        const results = await db`
            UPDATE manual_logs
            SET content = ${content}, updated_at = CURRENT_TIMESTAMP
            WHERE activity_id = ${activityId}
            RETURNING *
        `
        return results[0] || null
    }

    static async delete(activityId: string): Promise<boolean> {
        const result = await db`DELETE FROM manual_logs WHERE activity_id = ${activityId}`
        return result.count > 0
    }
}
```

Create `backend/src/models/ConnectedLocalGitRepo.ts`:
```typescript
import { db } from '../config/database'

export interface ConnectedLocalGitRepoRow {
    id: string
    name: string
    local_repo_path: string
    remote_url: string | null
    is_active: boolean
    created_at: Date
    updated_at: Date
}

export interface CreateRepoData {
    name: string
    local_repo_path: string
    remote_url?: string
    is_active?: boolean
}

export class ConnectedLocalGitRepo {
    static async findAll(): Promise<ConnectedLocalGitRepoRow[]> {
        return await db`SELECT * FROM connected_local_git_repos ORDER BY created_at DESC`
    }

    static async findActive(): Promise<ConnectedLocalGitRepoRow[]> {
        return await db`SELECT * FROM connected_local_git_repos WHERE is_active = true ORDER BY created_at DESC`
    }

    static async findByPath(path: string): Promise<ConnectedLocalGitRepoRow | null> {
        const results = await db`SELECT * FROM connected_local_git_repos WHERE local_repo_path = ${path}`
        return results[0] || null
    }

    static async create(data: CreateRepoData): Promise<ConnectedLocalGitRepoRow> {
        const results = await db`
            INSERT INTO connected_local_git_repos (name, local_repo_path, remote_url, is_active)
            VALUES (${data.name}, ${data.local_repo_path}, ${data.remote_url || null}, ${data.is_active || true})
            RETURNING *
        `
        return results[0]
    }

    static async delete(id: string): Promise<boolean> {
        const result = await db`DELETE FROM connected_local_git_repos WHERE id = ${id}`
        return result.count > 0
    }
}
```

Create `backend/src/models/GitCommit.ts`:
```typescript
import { db } from '../config/database'

export interface GitCommitRow {
    id: string
    activity_id: string
    repo_id: string
    commit_hash: string
    message: string
    author_name: string | null
    author_email: string | null
    committed_at: Date
    files_changed: string[] | null
    metadata: object | null
}

export interface CreateGitCommitData {
    activity_id: string
    repo_id: string
    commit_hash: string
    message: string
    author_name?: string
    author_email?: string
    committed_at: Date
    files_changed?: string[]
    metadata?: object
}

export class GitCommit {
    static async findByActivityId(activityId: string): Promise<GitCommitRow | null> {
        const results = await db`SELECT * FROM git_commits WHERE activity_id = ${activityId}`
        return results[0] || null
    }

    static async create(data: CreateGitCommitData): Promise<GitCommitRow> {
        const results = await db`
            INSERT INTO git_commits (activity_id, repo_id, commit_hash, message, author_name, author_email, committed_at, files_changed, metadata)
            VALUES (${data.activity_id}, ${data.repo_id}, ${data.commit_hash}, ${data.message}, ${data.author_name || null}, ${data.author_email || null}, ${data.committed_at}, ${data.files_changed || null}, ${data.metadata || null})
            RETURNING *
        `
        return results[0]
    }

    static async findByHash(hash: string, repoId: string): Promise<GitCommitRow | null> {
        const results = await db`SELECT * FROM git_commits WHERE commit_hash = ${hash} AND repo_id = ${repoId}`
        return results[0] || null
    }

    static async delete(activityId: string): Promise<boolean> {
        const result = await db`DELETE FROM git_commits WHERE activity_id = ${activityId}`
        return result.count > 0
    }
}
```

Create `backend/src/models/ClaudeCodeConversation.ts`:
```typescript
import { db } from '../config/database'

export interface ClaudeCodeConversationRow {
    id: string
    activity_id: string
    project_directory_name: string | null
    conversation_file_path: string
    raw_jsonl: string | null
    parsed_content: object | null
    bullet_points: string[] | null
    num_exchanges: number
    num_tool_usages: number
    num_tokens: number
    started_at: Date | null
    ended_at: Date | null
    metadata: object | null
}

export interface CreateConversationData {
    activity_id: string
    project_directory_name?: string
    conversation_file_path: string
    raw_jsonl?: string
    parsed_content?: object
    bullet_points?: string[]
    num_exchanges?: number
    num_tool_usages?: number
    num_tokens?: number
    started_at?: Date
    ended_at?: Date
    metadata?: object
}

export class ClaudeCodeConversation {
    static async findByActivityId(activityId: string): Promise<ClaudeCodeConversationRow | null> {
        const results = await db`SELECT * FROM claude_code_conversations WHERE activity_id = ${activityId}`
        return results[0] || null
    }

    static async create(data: CreateConversationData): Promise<ClaudeCodeConversationRow> {
        const results = await db`
            INSERT INTO claude_code_conversations (activity_id, project_directory_name, conversation_file_path, raw_jsonl, parsed_content, bullet_points, num_exchanges, num_tool_usages, num_tokens, started_at, ended_at, metadata)
            VALUES (${data.activity_id}, ${data.project_directory_name || null}, ${data.conversation_file_path}, ${data.raw_jsonl || null}, ${data.parsed_content || null}, ${data.bullet_points || null}, ${data.num_exchanges || 0}, ${data.num_tool_usages || 0}, ${data.num_tokens || 0}, ${data.started_at || null}, ${data.ended_at || null}, ${data.metadata || null})
            RETURNING *
        `
        return results[0]
    }

    static async delete(activityId: string): Promise<boolean> {
        const result = await db`DELETE FROM claude_code_conversations WHERE activity_id = ${activityId}`
        return result.count > 0
    }
}
```

Create `backend/src/models/GitCheckout.ts`:
```typescript
import { db } from '../config/database'

export interface GitCheckoutRow {
    id: string
    activity_id: string
    repo_id: string
    timestamp: string
    prev_head: string
    new_head: string
    prev_branch: string
    new_branch: string
    repo_path: string
    repo_name: string
    created_at: Date
}

export interface CreateCheckoutData {
    activity_id: string
    repo_id: string
    timestamp: string
    prev_head: string
    new_head: string
    prev_branch: string
    new_branch: string
    repo_path: string
    repo_name: string
}

export class GitCheckout {
    static async findByActivityId(activityId: string): Promise<GitCheckoutRow | null> {
        const results = await db`SELECT * FROM git_checkouts WHERE activity_id = ${activityId}`
        return results[0] || null
    }

    static async create(data: CreateCheckoutData): Promise<GitCheckoutRow> {
        const results = await db`
            INSERT INTO git_checkouts (activity_id, repo_id, timestamp, prev_head, new_head, prev_branch, new_branch, repo_path, repo_name)
            VALUES (${data.activity_id}, ${data.repo_id}, ${data.timestamp}, ${data.prev_head}, ${data.new_head}, ${data.prev_branch}, ${data.new_branch}, ${data.repo_path}, ${data.repo_name})
            RETURNING *
        `
        return results[0]
    }

    static async delete(activityId: string): Promise<boolean> {
        const result = await db`DELETE FROM git_checkouts WHERE activity_id = ${activityId}`
        return result.count > 0
    }
}
```

Create `backend/src/models/GitHooksInstalled.ts`:
```typescript
import { db } from '../config/database'

export interface GitHooksInstalledRow {
    id: string
    activity_id: string
    repo_id: string
    hook_type: string
    hook_script_path: string | null
    installation_timestamp: Date
    repo_path: string
    repo_name: string
    metadata: object | null
    created_at: Date
}

export interface CreateHookData {
    activity_id: string
    repo_id: string
    hook_type: string
    hook_script_path?: string
    installation_timestamp: Date
    repo_path: string
    repo_name: string
    metadata?: object
}

export class GitHooksInstalled {
    static async findByRepo(repoId: string): Promise<GitHooksInstalledRow[]> {
        return await db`SELECT * FROM git_hooks_installed WHERE repo_id = ${repoId} ORDER BY created_at DESC`
    }

    static async create(data: CreateHookData): Promise<GitHooksInstalledRow> {
        const results = await db`
            INSERT INTO git_hooks_installed (activity_id, repo_id, hook_type, hook_script_path, installation_timestamp, repo_path, repo_name, metadata)
            VALUES (${data.activity_id}, ${data.repo_id}, ${data.hook_type}, ${data.hook_script_path || null}, ${data.installation_timestamp}, ${data.repo_path}, ${data.repo_name}, ${data.metadata || null})
            RETURNING *
        `
        return results[0]
    }

    static async delete(activityId: string): Promise<boolean> {
        const result = await db`DELETE FROM git_hooks_installed WHERE activity_id = ${activityId}`
        return result.count > 0
    }
}
```

Create `backend/src/models/index.ts`:
```typescript
export * from './ActivityLog'
export * from './ManualLog'
export * from './ConnectedLocalGitRepo'
export * from './GitCommit'
export * from './ClaudeCodeConversation'
export * from './GitCheckout'
export * from './GitHooksInstalled'
```

### Step 3.4: Type Definitions and Validation Schemas
Create `backend/src/types/api.ts`:
```typescript
import { z } from 'zod'

// Activity Log Types
export const ActivityLogTypeSchema = z.enum(['manual', 'git_commit', 'claude_code', 'git_checkout', 'git_hook_install'])
export type ActivityLogType = z.infer<typeof ActivityLogTypeSchema>

// Details Schemas
export const ManualLogDetailsSchema = z.object({
    content: z.string().min(1, 'Content cannot be empty').max(10000, 'Content cannot exceed 10000 characters')
})

export const GitCommitDetailsSchema = z.object({
    commit_hash: z.string(),
    message: z.string(),
    author_name: z.string().optional(),
    author_email: z.string().email().optional(),
    committed_at: z.string(),
    files_changed: z.array(z.string()).optional()
})

export const ClaudeCodeDetailsSchema = z.object({
    project_directory_name: z.string().optional(),
    conversation_file_path: z.string(),
    bullet_points: z.array(z.string()).optional(),
    num_exchanges: z.number().int().min(0),
    num_tool_usages: z.number().int().min(0),
    num_tokens: z.number().int().min(0),
    started_at: z.string().optional(),
    ended_at: z.string().optional()
})

export const GitCheckoutDetailsSchema = z.object({
    timestamp: z.string(),
    prev_head: z.string(),
    new_head: z.string(),
    prev_branch: z.string(),
    new_branch: z.string(),
    repo_path: z.string(),
    repo_name: z.string()
})

export const GitHookDetailsSchema = z.object({
    hook_type: z.string(),
    hook_script_path: z.string().optional(),
    installation_timestamp: z.string(),
    repo_path: z.string(),
    repo_name: z.string()
})

export const ActivityLogDetailsSchema = z.union([
    ManualLogDetailsSchema,
    GitCommitDetailsSchema,
    ClaudeCodeDetailsSchema,
    GitCheckoutDetailsSchema,
    GitHookDetailsSchema
])

export type ManualLogDetails = z.infer<typeof ManualLogDetailsSchema>
export type GitCommitDetails = z.infer<typeof GitCommitDetailsSchema>
export type ClaudeCodeDetails = z.infer<typeof ClaudeCodeDetailsSchema>
export type GitCheckoutDetails = z.infer<typeof GitCheckoutDetailsSchema>
export type GitHookDetails = z.infer<typeof GitHookDetailsSchema>
export type ActivityLogDetails = z.infer<typeof ActivityLogDetailsSchema>

// Response Schema
export const ActivityLogResponseSchema = z.object({
    id: z.string().uuid(),
    type: ActivityLogTypeSchema,
    reviewed: z.boolean(),
    created_at: z.string(),
    reviewed_at: z.string().nullable(),
    details: ActivityLogDetailsSchema
})

export type ActivityLogResponse = z.infer<typeof ActivityLogResponseSchema>

// Filter Schema
export const ActivityLogFiltersSchema = z.object({
    from_date: z.string().optional(),
    to_date: z.string().optional(),
    reviewed: z.boolean().optional(),
    type: ActivityLogTypeSchema.optional()
}).optional()

export type ActivityLogFilters = z.infer<typeof ActivityLogFiltersSchema>

// Request Schemas
export const CreateManualLogRequestSchema = z.object({
    details: ManualLogDetailsSchema
})

export const UpdateActivityLogRequestSchema = z.object({
    details: ManualLogDetailsSchema.optional(),
    reviewed: z.boolean().optional()
})

export const ActivityLogSearchRequestSchema = z.object({
    filters: ActivityLogFiltersSchema
})

export const UUIDSchema = z.string().uuid('Invalid UUID format')

export type CreateManualLogRequest = z.infer<typeof CreateManualLogRequestSchema>
export type UpdateActivityLogRequest = z.infer<typeof UpdateActivityLogRequestSchema>
export type ActivityLogSearchRequest = z.infer<typeof ActivityLogSearchRequestSchema>
```

### Step 3.5: Services Layer (with Zod validation)
Create `backend/src/services/DatabaseService.ts`:
```typescript
import { ActivityLog, ManualLog, ActivityLogFilters, ActivityLogRow, CreateActivityLogData, UpdateActivityLogData } from '../models'
import { UpdateActivityLogRequest } from '../types/api'

export class DatabaseService {
    static async getActivityLogs(filters?: ActivityLogFilters): Promise<{log: ActivityLogRow, manualLog?: any}[]> {
        const logs = await ActivityLog.findAll(filters)
        const results = []

        for (const log of logs) {
            const result: any = { log }

            if (log.type === 'manual') {
                const manualLog = await ManualLog.findByActivityId(log.id)
                if (manualLog) {
                    result.manualLog = manualLog
                }
            }

            results.push(result)
        }

        return results
    }

    static async createManualLog(content: string): Promise<{log: ActivityLogRow, manualLog: any}> {
        const activityLog = await ActivityLog.create({ type: 'manual' })
        const manualLog = await ManualLog.create(activityLog.id, content)

        return { log: activityLog, manualLog }
    }

    static async updateManualLog(id: string, data: UpdateActivityLogRequest): Promise<{log: ActivityLogRow | null, manualLog?: any}> {
        const result: any = {}

        if (data.reviewed !== undefined) {
            result.log = await ActivityLog.update(id, {
                reviewed: data.reviewed,
                reviewed_at: data.reviewed ? new Date() : null
            })
        }

        if (data.details?.content) {
            result.manualLog = await ManualLog.update(id, data.details.content)
        }

        if (!result.log) {
            result.log = await ActivityLog.findById(id)
        }

        return result
    }

    static async deleteActivityLog(id: string): Promise<void> {
        const log = await ActivityLog.findById(id)
        if (!log) {
            throw new Error('Activity log not found')
        }

        // Cascade DELETE is handled by database constraints
        await ActivityLog.delete(id)
    }

    static async markLogsAsReviewed(ids: string[]): Promise<ActivityLogRow[]> {
        return await ActivityLog.markAsReviewed(ids)
    }
}
```

Create `backend/src/services/ActivityLogService.ts`:
```typescript
import { DatabaseService } from './DatabaseService'
import {
    ActivityLogFilters,
    ActivityLogResponse,
    UpdateActivityLogRequest,
    ManualLogDetailsSchema,
    UUIDSchema,
    ActivityLogFiltersSchema
} from '../types/api'
import { ActivityLogRow } from '../models'
import { z } from 'zod'

export class ValidationError extends Error {
    constructor(message: string, public statusCode: number = 400) {
        super(message)
        this.name = 'ValidationError'
    }
}

export class NotFoundError extends Error {
    constructor(message: string) {
        super(message)
        this.name = 'NotFoundError'
    }
}

export class ActivityLogService {
    static async getFilteredLogs(filters?: ActivityLogFilters): Promise<ActivityLogResponse[]> {
        // Validate filters if provided
        if (filters) {
            ActivityLogFiltersSchema.parse(filters)
        }

        const results = await DatabaseService.getActivityLogs(filters)
        return results.map(result => this.formatLogResponse(result.log, result.manualLog))
    }

    static async getUnreviewedLogs(): Promise<ActivityLogResponse[]> {
        const filters: ActivityLogFilters = { reviewed: false }
        const logs = await this.getFilteredLogs(filters)

        // Mark as reviewed after viewing
        if (logs.length > 0) {
            const ids = logs.map(log => log.id)
            await DatabaseService.markLogsAsReviewed(ids)
        }

        return logs
    }

    static async createManualEntry(content: string): Promise<ActivityLogResponse> {
        // Validate content using Zod
        const validation = ManualLogDetailsSchema.safeParse({ content })
        if (!validation.success) {
            throw new ValidationError(validation.error.errors[0].message)
        }

        const result = await DatabaseService.createManualLog(content)
        return this.formatLogResponse(result.log, result.manualLog)
    }

    static async updateEntry(id: string, data: UpdateActivityLogRequest): Promise<ActivityLogResponse> {
        // Validate UUID
        const idValidation = UUIDSchema.safeParse(id)
        if (!idValidation.success) {
            throw new ValidationError('Invalid UUID format')
        }

        await this.validateEntryExists(id)

        // Validate content if provided
        if (data.details?.content) {
            const validation = ManualLogDetailsSchema.safeParse(data.details)
            if (!validation.success) {
                throw new ValidationError(validation.error.errors[0].message)
            }
        }

        const result = await DatabaseService.updateManualLog(id, data)
        if (!result.log) {
            throw new NotFoundError('Activity log not found after update')
        }

        return this.formatLogResponse(result.log, result.manualLog)
    }

    static async deleteEntry(id: string): Promise<void> {
        // Validate UUID
        const idValidation = UUIDSchema.safeParse(id)
        if (!idValidation.success) {
            throw new ValidationError('Invalid UUID format')
        }

        await this.validateEntryExists(id)
        await DatabaseService.deleteActivityLog(id)
    }

    private static formatLogResponse(log: ActivityLogRow, details?: any): ActivityLogResponse {
        const response: ActivityLogResponse = {
            id: log.id,
            type: log.type,
            reviewed: log.reviewed,
            created_at: log.created_at.toISOString(),
            reviewed_at: log.reviewed_at?.toISOString() || null,
            details: {}
        }

        if (log.type === 'manual' && details) {
            response.details = { content: details.content }
        }

        return response
    }

    private static async validateEntryExists(id: string): Promise<void> {
        const result = await DatabaseService.getActivityLogs()
        const log = result.find(r => r.log.id === id)

        if (!log) {
            throw new NotFoundError('Activity log not found')
        }

        if (log.log.type !== 'manual') {
            throw new ValidationError('Can only modify manual log entries')
        }
    }
}
```

### Step 3.6: Middleware (with Zod validation)
Create `backend/src/middleware/validation.ts`:
```typescript
import { Request, Response, NextFunction } from 'express'
import {
    CreateManualLogRequestSchema,
    UpdateActivityLogRequestSchema,
    ActivityLogSearchRequestSchema,
    UUIDSchema
} from '../types/api'

export function validateCreateManualLog(req: Request, res: Response, next: NextFunction): void {
    const validation = CreateManualLogRequestSchema.safeParse(req.body)

    if (!validation.success) {
        return res.status(400).json({
            error: 'Validation failed',
            details: validation.error.errors
        })
    }

    next()
}

export function validateUpdateActivityLog(req: Request, res: Response, next: NextFunction): void {
    const validation = UpdateActivityLogRequestSchema.safeParse(req.body)

    if (!validation.success) {
        return res.status(400).json({
            error: 'Validation failed',
            details: validation.error.errors
        })
    }

    next()
}

export function validateSearchRequest(req: Request, res: Response, next: NextFunction): void {
    const validation = ActivityLogSearchRequestSchema.safeParse(req.body)

    if (!validation.success) {
        return res.status(400).json({
            error: 'Validation failed',
            details: validation.error.errors
        })
    }

    next()
}

export function validateUUID(paramName: string) {
    return (req: Request, res: Response, next: NextFunction): void => {
        const param = req.params[paramName]
        const validation = UUIDSchema.safeParse(param)

        if (!validation.success) {
            return res.status(400).json({
                error: `${paramName} must be a valid UUID`,
                details: validation.error.errors
            })
        }

        next()
    }
}
```

Create `backend/src/middleware/errorHandler.ts`:
```typescript
import { Request, Response, NextFunction } from 'express'
import { ZodError } from 'zod'

export function errorHandler(error: Error, req: Request, res: Response, next: NextFunction): void {
    console.error('Error:', error)

    if (error instanceof ZodError) {
        return res.status(400).json({
            error: 'Validation failed',
            details: error.errors
        })
    }

    if (error.name === 'ValidationError') {
        return res.status(400).json({ error: error.message })
    }

    if (error.name === 'NotFoundError') {
        return res.status(404).json({ error: error.message })
    }

    res.status(500).json({ error: 'Internal server error' })
}

export class ValidationError extends Error {
    constructor(message: string, public statusCode: number = 400) {
        super(message)
        this.name = 'ValidationError'
    }
}

export class NotFoundError extends Error {
    constructor(message: string) {
        super(message)
        this.name = 'NotFoundError'
    }
}
```

### Step 3.7: Routes (POST-based API with body parameters)
Create `backend/src/routes/activityLogs.ts`:
```typescript
import express from 'express'
import { ActivityLogService } from '../services/ActivityLogService'
import { validateCreateManualLog, validateUpdateActivityLog, validateSearchRequest, validateUUID } from '../middleware/validation'
import { ActivityLogSearchRequest } from '../types/api'

const router = express.Router()

// POST for searching logs (using body instead of query params)
router.post('/search', validateSearchRequest, async (req, res, next) => {
    try {
        const { filters }: ActivityLogSearchRequest = req.body
        const logs = await ActivityLogService.getFilteredLogs(filters)
        res.json(logs)
    } catch (error) {
        next(error)
    }
})

// Keep GET for simple listing (no filters)
router.get('/', async (req, res, next) => {
    try {
        const logs = await ActivityLogService.getFilteredLogs()
        res.json(logs)
    } catch (error) {
        next(error)
    }
})

router.post('/', validateCreateManualLog, async (req, res, next) => {
    try {
        const { details } = req.body
        const log = await ActivityLogService.createManualEntry(details.content)
        res.status(201).json(log)
    } catch (error) {
        next(error)
    }
})

router.put('/:id', validateUUID('id'), validateUpdateActivityLog, async (req, res, next) => {
    try {
        const { id } = req.params
        const log = await ActivityLogService.updateEntry(id, req.body)
        res.json(log)
    } catch (error) {
        next(error)
    }
})

router.delete('/:id', validateUUID('id'), async (req, res, next) => {
    try {
        const { id } = req.params
        await ActivityLogService.deleteEntry(id)
        res.status(204).send()
    } catch (error) {
        next(error)
    }
})

export default router
```

### Step 3.8: Main Server File
Create `backend/src/index.ts`:
```typescript
import express from 'express'
import cors from 'cors'
import activityLogsRouter from './routes/activityLogs'
import { errorHandler } from './middleware/errorHandler'

export class Server {
    private app: express.Application

    constructor() {
        this.app = express()
        this.setupMiddleware()
        this.setupRoutes()
        this.setupErrorHandling()
    }

    private setupMiddleware(): void {
        this.app.use(express.json({ limit: '10mb' }))
        this.app.use(cors({
            origin: process.env.FRONTEND_URL || 'http://localhost:3000',
            credentials: true
        }))
    }

    private setupRoutes(): void {
        this.app.use('/api/v1/activity-logs', activityLogsRouter)

        // Health check endpoint
        this.app.get('/health', (req, res) => {
            res.json({ status: 'ok', timestamp: new Date().toISOString() })
        })
    }

    private setupErrorHandling(): void {
        this.app.use(errorHandler)
    }

    public start(port: number): void {
        this.app.listen(port, () => {
            console.log(`Server running on port ${port}`)
        })
    }

    public getApp(): express.Application {
        return this.app
    }
}

const server = new Server()
const port = process.env.PORT ? parseInt(process.env.PORT) : 3001
server.start(port)
```

## Phase 4: Frontend Implementation (V0.5)

### Step 4.1: Initialize Frontend Package
Create `frontend/package.json`:
```json
{
  "name": "fuel-frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "axios": "^1.6.0",
    "zustand": "^4.4.7"
  },
  "devDependencies": {
    "@types/react": "^18.2.43",
    "@types/react-dom": "^18.2.17",
    "@typescript-eslint/eslint-plugin": "^6.14.0",
    "@typescript-eslint/parser": "^6.14.0",
    "@vitejs/plugin-react": "^4.2.1",
    "eslint": "^8.55.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "typescript": "^5.2.2",
    "vite": "^5.0.8"
  }
}
```

Create `frontend/tsconfig.json`:
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

Create `frontend/tsconfig.node.json`:
```json
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
```

Create `frontend/vite.config.ts`:
```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    port: parseInt(process.env.VITE_PORT || '3000'),
    proxy: {
      '/api': {
        target: process.env.VITE_API_URL || 'http://localhost:3001',
        changeOrigin: true,
      },
    },
  },
})
```

Install frontend dependencies:
```bash
cd ../frontend
npm install
```

### Step 4.2: Create Frontend Types
Create `frontend/src/types/api.ts`:
```typescript
export interface ActivityLogResponse {
    id: string
    type: 'manual' | 'git_commit' | 'claude_code' | 'git_checkout' | 'git_hook_install'
    reviewed: boolean
    created_at: string
    reviewed_at: string | null
    details: ManualLogDetails | GitCommitDetails | ClaudeCodeDetails | GitCheckoutDetails | GitHookDetails
}

export interface ManualLogDetails {
    content: string
}

export interface GitCommitDetails {
    commit_hash: string
    message: string
    author_name?: string
    author_email?: string
    committed_at: string
    files_changed?: string[]
}

export interface ClaudeCodeDetails {
    project_directory_name?: string
    conversation_file_path: string
    bullet_points?: string[]
    num_exchanges: number
    num_tool_usages: number
    num_tokens: number
    started_at?: string
    ended_at?: string
}

export interface GitCheckoutDetails {
    timestamp: string
    prev_head: string
    new_head: string
    prev_branch: string
    new_branch: string
    repo_path: string
    repo_name: string
}

export interface GitHookDetails {
    hook_type: string
    hook_script_path?: string
    installation_timestamp: string
    repo_path: string
    repo_name: string
}

export interface ActivityLogFilters {
    from_date?: string
    to_date?: string
    reviewed?: boolean
    type?: string
}

export interface CreateManualLogRequest {
    details: { content: string }
}

export interface UpdateActivityLogRequest {
    details?: { content: string }
    reviewed?: boolean
}

export interface ActivityLogSearchRequest {
    filters?: ActivityLogFilters
}
```

### Step 4.3: API Service (POST-based with body parameters)
Create `frontend/src/services/api.ts`:
```typescript
import axios from 'axios'
import { ActivityLogResponse, ActivityLogFilters, CreateManualLogRequest, UpdateActivityLogRequest, ActivityLogSearchRequest } from '../types/api'

export class ApiService {
    private baseURL: string
    private client: axios.AxiosInstance

    constructor() {
        this.baseURL = import.meta.env.VITE_API_URL || 'http://localhost:3001'
        this.client = axios.create({
            baseURL: this.baseURL,
            timeout: 10000,
            headers: {
                'Content-Type': 'application/json',
            },
        })

        this.client.interceptors.response.use(
            (response) => response,
            (error) => {
                console.error('API Error:', error)
                return Promise.reject(this.handleError(error))
            }
        )
    }

    async getActivityLogs(filters?: ActivityLogFilters): Promise<ActivityLogResponse[]> {
        if (filters && Object.keys(filters).length > 0) {
            // Use POST /search for filtered requests
            const request: ActivityLogSearchRequest = { filters }
            const response = await this.client.post('/api/v1/activity-logs/search', request)
            return response.data
        } else {
            // Use GET for simple listing
            const response = await this.client.get('/api/v1/activity-logs')
            return response.data
        }
    }

    async createManualLog(content: string): Promise<ActivityLogResponse> {
        const request: CreateManualLogRequest = {
            details: { content }
        }
        const response = await this.client.post('/api/v1/activity-logs', request)
        return response.data
    }

    async updateActivityLog(id: string, data: UpdateActivityLogRequest): Promise<ActivityLogResponse> {
        const response = await this.client.put(`/api/v1/activity-logs/${id}`, data)
        return response.data
    }

    async deleteActivityLog(id: string): Promise<void> {
        await this.client.delete(`/api/v1/activity-logs/${id}`)
    }

    private handleError(error: axios.AxiosError): Error {
        if (error.response?.data && typeof error.response.data === 'object' && 'error' in error.response.data) {
            return new Error((error.response.data as any).error)
        }

        if (error.response?.status === 404) {
            return new Error('Resource not found')
        }

        if (error.response?.status >= 500) {
            return new Error('Server error occurred')
        }

        return new Error('Network error occurred')
    }
}

export const apiService = new ApiService()
```

### Step 4.4: State Management
Create `frontend/src/stores/appStore.ts`:
```typescript
import { create } from 'zustand'
import { apiService } from '../services/api'
import { ActivityLogResponse, ActivityLogFilters, UpdateActivityLogRequest } from '../types/api'

interface AppState {
    activityLogs: ActivityLogResponse[]
    filters: ActivityLogFilters
    loading: boolean
    error: string | null
}

interface AppActions {
    setFilters: (filters: ActivityLogFilters) => void
    loadActivityLogs: () => Promise<void>
    createManualLog: (content: string) => Promise<void>
    updateActivityLog: (id: string, data: UpdateActivityLogRequest) => Promise<void>
    deleteActivityLog: (id: string) => Promise<void>
    markLogsAsReviewed: (ids: string[]) => Promise<void>
    clearFilters: () => void
    setError: (error: string | null) => void
    setLoading: (loading: boolean) => void
}

export const useAppStore = create<AppState & AppActions>((set, get) => ({
    // State
    activityLogs: [],
    filters: {},
    loading: false,
    error: null,

    // Actions
    setFilters: (filters) => {
        set({ filters })
        get().loadActivityLogs()
    },

    loadActivityLogs: async () => {
        const state = get()
        set({ loading: true, error: null })

        try {
            const logs = await apiService.getActivityLogs(state.filters)
            set({ activityLogs: logs })
        } catch (error) {
            set({ error: error instanceof Error ? error.message : 'Failed to load activity logs' })
        } finally {
            set({ loading: false })
        }
    },

    createManualLog: async (content) => {
        set({ loading: true, error: null })

        try {
            await apiService.createManualLog(content)
            await get().loadActivityLogs()
        } catch (error) {
            set({ error: error instanceof Error ? error.message : 'Failed to create manual log' })
            set({ loading: false })
        }
    },

    updateActivityLog: async (id, data) => {
        set({ loading: true, error: null })

        try {
            await apiService.updateActivityLog(id, data)
            await get().loadActivityLogs()
        } catch (error) {
            set({ error: error instanceof Error ? error.message : 'Failed to update activity log' })
            set({ loading: false })
        }
    },

    deleteActivityLog: async (id) => {
        set({ loading: true, error: null })

        try {
            await apiService.deleteActivityLog(id)
            await get().loadActivityLogs()
        } catch (error) {
            set({ error: error instanceof Error ? error.message : 'Failed to delete activity log' })
            set({ loading: false })
        }
    },

    markLogsAsReviewed: async (ids) => {
        if (ids.length === 0) return

        try {
            for (const id of ids) {
                await apiService.updateActivityLog(id, { reviewed: true })
            }
            await get().loadActivityLogs()
        } catch (error) {
            set({ error: error instanceof Error ? error.message : 'Failed to mark logs as reviewed' })
        }
    },

    clearFilters: () => {
        set({ filters: {} })
        get().loadActivityLogs()
    },

    setError: (error) => set({ error }),
    setLoading: (loading) => set({ loading }),
}))
```

### Step 4.5: Custom Hooks
Create `frontend/src/hooks/useActivityLogs.ts`:
```typescript
import { useEffect } from 'react'
import { useAppStore } from '../stores/appStore'

export function useActivityLogs() {
    const {
        activityLogs,
        loading,
        error,
        loadActivityLogs,
        deleteActivityLog,
        markLogsAsReviewed
    } = useAppStore()

    useEffect(() => {
        loadActivityLogs()
    }, [])

    const markUnreviewedAsReviewed = () => {
        const unreviewedIds = activityLogs
            .filter(log => !log.reviewed)
            .map(log => log.id)

        if (unreviewedIds.length > 0) {
            markLogsAsReviewed(unreviewedIds)
        }
    }

    const deleteLog = (id: string) => {
        deleteActivityLog(id)
    }

    return {
        activityLogs,
        loading,
        error,
        refresh: loadActivityLogs,
        markUnreviewedAsReviewed,
        deleteLog
    }
}
```

Create `frontend/src/hooks/useFilters.ts`:
```typescript
import { useState } from 'react'
import { useAppStore } from '../stores/appStore'
import { ActivityLogFilters } from '../types/api'

export function useFilters() {
    const { filters, setFilters, clearFilters } = useAppStore()
    const [tempFilters, setTempFilters] = useState<ActivityLogFilters>({})

    const applyFilters = () => {
        setFilters(tempFilters)
    }

    const resetFilters = () => {
        setTempFilters({})
        clearFilters()
    }

    const updateTempFilter = (key: keyof ActivityLogFilters, value: any) => {
        setTempFilters(prev => ({
            ...prev,
            [key]: value
        }))
    }

    return {
        filters,
        tempFilters,
        applyFilters,
        resetFilters,
        updateTempFilter
    }
}
```

### Step 4.6: Components (Updated titles and navigation)
Create `frontend/src/components/Header/Header.tsx`:
```typescript
import React from 'react'
import { FilterControls } from './FilterControls'

interface HeaderProps {
    showFilters: boolean
}

export function Header({ showFilters }: HeaderProps) {
    return (
        <header className="header">
            <div className="header-content">
                <h1 className="header-title">Fuel</h1>
                {showFilters && <FilterControls />}
            </div>
        </header>
    )
}
```

Create `frontend/src/components/Header/FilterControls.tsx`:
```typescript
import React from 'react'
import { useFilters } from '../../hooks/useFilters'

export function FilterControls() {
    const { tempFilters, applyFilters, resetFilters, updateTempFilter } = useFilters()

    return (
        <div className="filter-controls">
            <div className="filter-group">
                <label htmlFor="from-date">From Date:</label>
                <input
                    type="date"
                    id="from-date"
                    value={tempFilters.from_date || ''}
                    onChange={(e) => updateTempFilter('from_date', e.target.value)}
                />
            </div>

            <div className="filter-group">
                <label htmlFor="to-date">To Date:</label>
                <input
                    type="date"
                    id="to-date"
                    value={tempFilters.to_date || ''}
                    onChange={(e) => updateTempFilter('to_date', e.target.value)}
                />
            </div>

            <div className="filter-group">
                <label htmlFor="type-filter">Type:</label>
                <select
                    id="type-filter"
                    value={tempFilters.type || ''}
                    onChange={(e) => updateTempFilter('type', e.target.value || undefined)}
                >
                    <option value="">All Types</option>
                    <option value="manual">Manual</option>
                    <option value="git_commit">Git Commit</option>
                    <option value="claude_code">Claude Code</option>
                    <option value="git_checkout">Git Checkout</option>
                    <option value="git_hook_install">Git Hook Install</option>
                </select>
            </div>

            <div className="filter-actions">
                <button onClick={applyFilters} className="btn btn-primary">Apply</button>
                <button onClick={resetFilters} className="btn btn-secondary">Clear</button>
            </div>
        </div>
    )
}
```

Create `frontend/src/components/Sidebar/Sidebar.tsx`:
```typescript
import React from 'react'

interface SidebarProps {
    onLogViewClick: () => void
    isLogViewActive: boolean
}

export function Sidebar({ onLogViewClick, isLogViewActive }: SidebarProps) {
    return (
        <aside className="sidebar">
            <nav className="sidebar-nav">
                <div
                    className={`sidebar-nav-item ${isLogViewActive ? 'active' : ''}`}
                    onClick={onLogViewClick}
                >
                    Logs
                </div>

                <div className="sidebar-section">
                    <h3>Future Features</h3>
                    <div className="sidebar-placeholder">
                        More features coming soon...
                    </div>
                </div>
            </nav>
        </aside>
    )
}
```

Create `frontend/src/components/MainView/MainView.tsx`:
```typescript
import React, { useState } from 'react'
import { LogFeed } from './LogFeed'
import { ManualLogForm } from './ManualLogForm'

export function MainView() {
    const [currentView, setCurrentView] = useState<'logs' | 'create'>('logs')

    return (
        <main className="main-view">
            <div className="main-view-header">
                <div className="view-controls">
                    <button
                        className={`btn ${currentView === 'logs' ? 'btn-primary' : 'btn-secondary'}`}
                        onClick={() => setCurrentView('logs')}
                    >
                        Activity Logs
                    </button>
                    <button
                        className={`btn ${currentView === 'create' ? 'btn-primary' : 'btn-secondary'}`}
                        onClick={() => setCurrentView('create')}
                    >
                        Create Manual Log
                    </button>
                </div>
            </div>

            <div className="main-view-content">
                {currentView === 'logs' ? <LogFeed /> : <ManualLogForm />}
            </div>
        </main>
    )
}
```

Create `frontend/src/components/MainView/LogFeed.tsx`:
```typescript
import React, { useEffect } from 'react'
import { useActivityLogs } from '../../hooks/useActivityLogs'
import { LogEntry } from './LogEntry'

export function LogFeed() {
    const { activityLogs, loading, error, markUnreviewedAsReviewed } = useActivityLogs()

    useEffect(() => {
        // Mark unreviewed logs as reviewed when viewing
        const timer = setTimeout(() => {
            markUnreviewedAsReviewed()
        }, 2000) // 2 second delay before marking as reviewed

        return () => clearTimeout(timer)
    }, [activityLogs, markUnreviewedAsReviewed])

    if (loading) {
        return <div className="loading">Loading activity logs...</div>
    }

    if (error) {
        return <div className="error">Error: {error}</div>
    }

    if (activityLogs.length === 0) {
        return <div className="empty-state">No activity logs found.</div>
    }

    return (
        <div className="log-feed">
            <div className="log-feed-header">
                <h2>Activity Logs ({activityLogs.length})</h2>
            </div>

            <div className="log-entries">
                {activityLogs.map((log) => (
                    <LogEntry key={log.id} log={log} />
                ))}
            </div>
        </div>
    )
}
```

Create `frontend/src/components/MainView/LogEntry.tsx`:
```typescript
import React from 'react'
import { ActivityLogResponse, ManualLogDetails } from '../../types/api'
import { useActivityLogs } from '../../hooks/useActivityLogs'

interface LogEntryProps {
    log: ActivityLogResponse
}

export function LogEntry({ log }: LogEntryProps) {
    const { deleteLog } = useActivityLogs()

    const formatDate = (dateString: string) => {
        const date = new Date(dateString)
        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString()
    }

    const getTypeLabel = (type: string) => {
        const labels = {
            manual: 'Manual Log',
            git_commit: 'Git Commit',
            claude_code: 'Claude Code',
            git_checkout: 'Git Checkout',
            git_hook_install: 'Git Hook Install'
        }
        return labels[type as keyof typeof labels] || type
    }

    const renderDetails = () => {
        if (log.type === 'manual') {
            const details = log.details as ManualLogDetails
            return (
                <div className="log-content">
                    <p>{details.content}</p>
                </div>
            )
        }

        // For other types, show basic info
        return (
            <div className="log-content">
                <p>Details for {getTypeLabel(log.type)} coming soon...</p>
            </div>
        )
    }

    const handleDelete = () => {
        if (window.confirm('Are you sure you want to delete this log entry?')) {
            deleteLog(log.id)
        }
    }

    return (
        <div className={`log-entry ${!log.reviewed ? 'unreviewed' : ''}`}>
            <div className="log-entry-header">
                <div className="log-entry-meta">
                    <span className="log-type">{getTypeLabel(log.type)}</span>
                    <span className="log-date">{formatDate(log.created_at)}</span>
                    {!log.reviewed && <span className="unreviewed-badge">New</span>}
                </div>

                <div className="log-entry-actions">
                    <button
                        onClick={handleDelete}
                        className="btn btn-danger btn-small"
                        title="Delete log entry"
                    >
                        Delete
                    </button>
                </div>
            </div>

            {renderDetails()}
        </div>
    )
}
```

Create `frontend/src/components/MainView/ManualLogForm.tsx`:
```typescript
import React, { useState } from 'react'
import { useAppStore } from '../../stores/appStore'

export function ManualLogForm() {
    const [content, setContent] = useState('')
    const { createManualLog, loading, error } = useAppStore()

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault()

        if (!content.trim()) {
            return
        }

        try {
            await createManualLog(content.trim())
            setContent('')
        } catch (error) {
            // Error is handled by the store
        }
    }

    return (
        <div className="manual-log-form">
            <h2>Create Manual Log Entry</h2>

            {error && (
                <div className="error-message">
                    {error}
                </div>
            )}

            <form onSubmit={handleSubmit}>
                <div className="form-group">
                    <label htmlFor="content">Log Content:</label>
                    <textarea
                        id="content"
                        value={content}
                        onChange={(e) => setContent(e.target.value)}
                        placeholder="Enter your manual log content here..."
                        rows={6}
                        disabled={loading}
                        required
                    />
                </div>

                <div className="form-actions">
                    <button
                        type="submit"
                        className="btn btn-primary"
                        disabled={loading || !content.trim()}
                    >
                        {loading ? 'Creating...' : 'Create Log Entry'}
                    </button>

                    <button
                        type="button"
                        className="btn btn-secondary"
                        onClick={() => setContent('')}
                        disabled={loading}
                    >
                        Clear
                    </button>
                </div>
            </form>
        </div>
    )
}
```

### Step 4.7: Main App Components
Create `frontend/src/App.tsx`:
```typescript
import React, { useState } from 'react'
import { Header } from './components/Header/Header'
import { Sidebar } from './components/Sidebar/Sidebar'
import { MainView } from './components/MainView/MainView'
import './styles/index.css'

export function App() {
    const [isLogViewActive, setIsLogViewActive] = useState(true)

    const handleLogViewClick = () => {
        setIsLogViewActive(true)
    }

    return (
        <div className="app">
            <Header showFilters={isLogViewActive} />

            <div className="app-body">
                <Sidebar
                    onLogViewClick={handleLogViewClick}
                    isLogViewActive={isLogViewActive}
                />

                <MainView />
            </div>
        </div>
    )
}
```

Create `frontend/src/main.tsx`:
```typescript
import React from 'react'
import ReactDOM from 'react-dom/client'
import { App } from './App'
import './styles/index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>
)
```

Create `frontend/index.html`:
```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fuel Activity Logger</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

### Step 4.8: Styles
Create `frontend/src/styles/index.css`:
```css
/* Reset and base styles */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #f5f5f5;
}

/* App layout */
.app {
  height: 100vh;
  display: flex;
  flex-direction: column;
}

.app-body {
  flex: 1;
  display: flex;
  overflow: hidden;
}

/* Header */
.header {
  background: #2c3e50;
  color: white;
  padding: 1rem 2rem;
  border-bottom: 1px solid #34495e;
}

.header-content {
  display: flex;
  justify-content: space-between;
  align-items: center;
  max-width: 1200px;
  margin: 0 auto;
}

.header-title {
  font-size: 1.5rem;
  font-weight: 600;
}

/* Filter controls */
.filter-controls {
  display: flex;
  gap: 1rem;
  align-items: center;
}

.filter-group {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.filter-group label {
  font-size: 0.8rem;
  opacity: 0.9;
}

.filter-group input,
.filter-group select {
  padding: 0.25rem;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 0.9rem;
}

.filter-actions {
  display: flex;
  gap: 0.5rem;
}

/* Sidebar */
.sidebar {
  width: 200px;
  background: #ecf0f1;
  border-right: 1px solid #bdc3c7;
  padding: 1rem;
  overflow-y: auto;
}

.sidebar-nav {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.sidebar-nav-item {
  padding: 0.75rem;
  background: none;
  border: none;
  text-align: left;
  cursor: pointer;
  border-radius: 4px;
  transition: background-color 0.2s;
}

.sidebar-nav-item:hover {
  background: #d5dbdb;
}

.sidebar-nav-item.active {
  background: #3498db;
  color: white;
}

.sidebar-section {
  margin-top: 2rem;
}

.sidebar-section h3 {
  font-size: 0.9rem;
  margin-bottom: 0.5rem;
  color: #7f8c8d;
}

.sidebar-placeholder {
  padding: 0.5rem;
  font-size: 0.8rem;
  color: #95a5a6;
  font-style: italic;
}

/* Main view */
.main-view {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.main-view-header {
  padding: 1rem 2rem;
  background: white;
  border-bottom: 1px solid #ecf0f1;
}

.view-controls {
  display: flex;
  gap: 0.5rem;
}

.main-view-content {
  flex: 1;
  overflow: auto;
  padding: 2rem;
}

/* Buttons */
.btn {
  padding: 0.5rem 1rem;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: background-color 0.2s;
}

.btn-primary {
  background: #3498db;
  color: white;
}

.btn-primary:hover {
  background: #2980b9;
}

.btn-secondary {
  background: #95a5a6;
  color: white;
}

.btn-secondary:hover {
  background: #7f8c8d;
}

.btn-danger {
  background: #e74c3c;
  color: white;
}

.btn-danger:hover {
  background: #c0392b;
}

.btn-small {
  padding: 0.25rem 0.5rem;
  font-size: 0.8rem;
}

.btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

/* Log feed */
.log-feed {
  max-width: 800px;
  margin: 0 auto;
}

.log-feed-header {
  margin-bottom: 2rem;
}

.log-feed-header h2 {
  color: #2c3e50;
}

.log-entries {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

/* Log entry */
.log-entry {
  background: white;
  border: 1px solid #ecf0f1;
  border-radius: 8px;
  padding: 1.5rem;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.log-entry.unreviewed {
  border-left: 4px solid #f39c12;
}

.log-entry-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
}

.log-entry-meta {
  display: flex;
  gap: 1rem;
  align-items: center;
}

.log-type {
  background: #3498db;
  color: white;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-size: 0.8rem;
  font-weight: 500;
}

.log-date {
  color: #7f8c8d;
  font-size: 0.9rem;
}

.unreviewed-badge {
  background: #f39c12;
  color: white;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-size: 0.7rem;
  font-weight: 500;
}

.log-content p {
  color: #2c3e50;
  line-height: 1.6;
  white-space: pre-wrap;
}

/* Manual log form */
.manual-log-form {
  max-width: 600px;
  margin: 0 auto;
}

.manual-log-form h2 {
  color: #2c3e50;
  margin-bottom: 2rem;
}

.form-group {
  margin-bottom: 1.5rem;
}

.form-group label {
  display: block;
  margin-bottom: 0.5rem;
  color: #2c3e50;
  font-weight: 500;
}

.form-group textarea {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid #bdc3c7;
  border-radius: 4px;
  font-family: inherit;
  font-size: 1rem;
  resize: vertical;
}

.form-group textarea:focus {
  outline: none;
  border-color: #3498db;
}

.form-actions {
  display: flex;
  gap: 1rem;
}

/* Utility classes */
.loading {
  text-align: center;
  padding: 2rem;
  color: #7f8c8d;
}

.error {
  text-align: center;
  padding: 2rem;
  color: #e74c3c;
}

.error-message {
  background: #fadbd8;
  color: #a93226;
  padding: 1rem;
  border-radius: 4px;
  margin-bottom: 1rem;
}

.empty-state {
  text-align: center;
  padding: 4rem 2rem;
  color: #7f8c8d;
}

/* Responsive design */
@media (max-width: 768px) {
  .app-body {
    flex-direction: column;
  }

  .sidebar {
    width: 100%;
    height: auto;
    border-right: none;
    border-bottom: 1px solid #bdc3c7;
  }

  .main-view-content {
    padding: 1rem;
  }

  .filter-controls {
    flex-wrap: wrap;
  }

  .header-content {
    flex-direction: column;
    gap: 1rem;
  }
}
```

## Phase 5: Docker Configuration (V0.7)

### Step 5.1: Environment Configuration
Create `.env`:
```bash
# Database Configuration
POSTGRES_DB=fuel_db
POSTGRES_USER=fuel_user
POSTGRES_PASSWORD=fuel_password
DATABASE_URL=postgresql://fuel_user:fuel_password@postgres:5432/fuel_db

# Backend Configuration
BACKEND_PORT=3001
NODE_ENV=production
FRONTEND_URL=http://localhost:${FRONTEND_PORT}

# Frontend Configuration
FRONTEND_PORT=3000
VITE_API_URL=http://localhost:${BACKEND_PORT}
VITE_PORT=${FRONTEND_PORT}

# Docker Configuration
COMPOSE_PROJECT_NAME=fuel
```

### Step 5.2: Backend Docker Configuration
Create `backend/Dockerfile`:
```dockerfile
FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./
COPY tsconfig.json ./

# Install dependencies
RUN npm ci --only=production

# Copy source code
COPY src/ ./src/

# Build TypeScript
RUN npm run build

# Expose port
EXPOSE 3001

# Start application
CMD ["npm", "start"]
```

Create `backend/.dockerignore`:
```dockerignore
node_modules/
npm-debug.log
.git/
.gitignore
README.md
.env
.env.local
coverage/
.vscode/
.idea/
tests/
*.test.ts
*.spec.ts
src/**/*.test.ts
src/**/*.spec.ts
```

### Step 5.3: Frontend Docker Configuration
Create `frontend/Dockerfile`:
```dockerfile
FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./
COPY tsconfig.json ./
COPY tsconfig.node.json ./
COPY vite.config.ts ./
COPY index.html ./

# Install dependencies including serve
RUN npm ci

# Copy source code
COPY src/ ./src/

# Build application
RUN npm run build

# Install serve globally for production file serving
RUN npm install -g serve

# Expose port
EXPOSE 3000

# Serve built files
CMD ["serve", "-s", "dist", "-l", "3000"]
```

Create `frontend/.dockerignore`:
```dockerignore
node_modules/
npm-debug.log
.git/
.gitignore
README.md
.env
.env.local
coverage/
.vscode/
.idea/
dist/
build/
```

### Step 5.4: Docker Compose Configuration
Create `docker-compose.yml`:
```yaml
version: '3.8'

services:
  postgres:
    image: postgres:14
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/migrations:/docker-entrypoint-initdb.d
    networks:
      - fuel_backend_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5

  fuel_backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    environment:
      DATABASE_URL: ${DATABASE_URL}
      NODE_ENV: ${NODE_ENV}
      FRONTEND_URL: ${FRONTEND_URL}
    ports:
      - "${BACKEND_PORT}:3001"
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - fuel_backend_network
      - fuel_frontend_network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3001/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  fuel_frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      args:
        - VITE_API_URL=${VITE_API_URL}
    ports:
      - "${FRONTEND_PORT}:3000"
    depends_on:
      fuel_backend:
        condition: service_healthy
    networks:
      - fuel_frontend_network

volumes:
  postgres_data:

networks:
  fuel_backend_network:
    driver: bridge
  fuel_frontend_network:
    driver: bridge
```

### Step 5.5: Git Configuration
Update `.gitignore` (since git repo exists):
```gitignore
# Dependencies
node_modules/
*/node_modules/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Build outputs
dist/
build/
*/dist/
*/build/

# Runtime data
pids/
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/
*.lcov

# Docker
.dockerignore

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Temporary folders
tmp/
temp/

# Optional npm cache directory
.npm

# ESLint cache
.eslintcache

# TypeScript cache
*.tsbuildinfo

# Parcel-bundler cache
.cache
.parcel-cache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history
```

## Phase 6: Build and Verification Commands

### Step 6.1: Build Commands Sequence
Navigate to project directory and execute:
```bash
cd ~/Desktop/fuel

# Step 1: Install backend dependencies
cd backend && npm install && cd ..

# Step 2: Install frontend dependencies
cd frontend && npm install && cd ..

# Step 3: Build and start services with Docker Compose
docker-compose up --build -d

# Step 4: Wait for services to start
sleep 30

# Step 5: Check service health
docker-compose ps
docker-compose logs fuel_backend
docker-compose logs fuel_frontend
```

### Step 6.2: Verification Commands
```bash
# Test backend health endpoint
curl -f http://localhost:3001/health

# Test backend API - simple listing
curl -f http://localhost:3001/api/v1/activity-logs

# Test backend API - search with filters
curl -X POST http://localhost:3001/api/v1/activity-logs/search \
  -H "Content-Type: application/json" \
  -d '{"filters": {"reviewed": false}}'

# Test frontend accessibility
curl -f http://localhost:3000

# Check database connection
docker-compose exec postgres psql -U fuel_user -d fuel_db -c "\dt"

# Create a test manual log
curl -X POST http://localhost:3001/api/v1/activity-logs \
  -H "Content-Type: application/json" \
  -d '{"details": {"content": "Test manual log entry"}}'

# Verify the log was created
curl -f http://localhost:3001/api/v1/activity-logs
```

### Step 6.3: Access Points
After successful build and verification:
- **Frontend Application**: http://localhost:3000
- **Backend API**: http://localhost:3001/api/v1/activity-logs
- **Backend Health Check**: http://localhost:3001/health
- **Database**: Accessible via backend on port 5432 (internal to Docker network)

### Step 6.4: Cleanup Commands (Optional)
```bash
# Stop all services
docker-compose down

# Stop and remove volumes (WARNING: This will delete all data)
docker-compose down -v

# Remove built images
docker-compose down --rmi all
```

## Success Criteria

After following all steps, you should have:

 **Database Layer**: PostgreSQL with all tables, indexes, and relationships
 **Backend API**: Express server with all endpoints, validation, and error handling using Zod
 **Frontend App**: React application with components, state management, and API integration
 **Docker Environment**: Complete containerized deployment
 **Working Application**: Accessible at http://localhost:3000 with functional manual log creation, viewing, filtering, and deletion
 **API Functionality**: All CRUD operations for activity logs working via REST endpoints with POST-based search
 **Database Persistence**: Data survives container restarts via Docker volumes
 **Delete Support**: All database models support proper deletion methods
 **Environment Variables**: Configuration uses environment variables instead of hardcoded values
 **POST-based Search**: Frontend uses POST requests with body parameters instead of URL query strings
 **Zod Validation**: All API validation uses Zod schemas instead of manual validation

The application will be ready for future integration with git hooks, Claude Code conversations, and additional activity tracking features.